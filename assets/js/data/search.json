[ { "title": "DDD 사이드 프로젝트에 적용해보기(1)", "url": "/posts/apply-ddd-to-project/", "categories": "아키텍쳐", "tags": "domain-driven design, DDD, SpringBoot", "date": "2023-09-02 22:00:00 +0900", "snippet": "사이드 프로젝트를 진행하면서 Implementing Domain-Driven Design을 읽고 있었다. 내용이 너무 커서 책을 읽는 속도가 프로젝트 진행속도에 따라가지 못했다. 이에 같은 저자의 가벼운 Domain-Driven Desiong Distlled를 읽고 프로젝트에 적용해보려고 한다.바운디드 컨텍스트 정의우리 프로젝트는 헬스 기록을 등록하면 랭킹을 보여주는 앱이다. 현재 정의된 기능을 간단하게 나열하면 다음과 같다. 3대 측정 기록 등록 측정 기록 인증 3대 측정 순위 표출 주위 헬스장 안내 헬스장 기구 정보/리뷰 표시 회원 가입 / 로그인 회원 정보 수정Ranking, Gym, User 이렇게 세개의 바운디드 컨텍스트로 나누고 Ranking을 Core 도메인으로 정의했다. 기록을 등록하는 Record를 따로 분리할지 고민했는데 기록 등록은 랭킹을 산정하기위한 서브도메인이라는 결론을 내렸다.회원정보를 관리하는 User와 토큰 발급(로그인)/인증을 관리하는 Auth를 분리할지도 고민됐다. 명확히 하기위해 다음과 같이 회원가입/로그인 시나리오를 적어봤다.사용자는 카카오나 구글 OAuth를 통해 sid를 발급받고 sid가 등록되어있으면 로크인, 되어있지 않으면 회원가입을 한다. 회원가입이 완료되면 자체 id가 발급된다. 로그인 시 자체 id를 포함한 토큰을 발급받는다. 토큰은 rsa알고리즘으로 서명되며 각각의 서버에서 자체적으로 인증한다.토큰 발급 시 회원식별자와 sid만 필요하고 나머지 회원정보를 알지 못해도 되고 로그인과 회원정보의 트렌젝션 범위가 구분되므로 auth가 다른 바운디드 컨텍스트로 분리되어도 될것같다. 하지만 로그인 하나만으로 컨텍스트를 쪼개기에는 너무 범위가 작은 것 같아 User에 통합했다.Ranking core domain 정의랭킹 등록 시나리오는 다음과 같다.회원가입한 유저는 기록을 등록할 수 있다. 기록을 등록할 수 있는 종목은 스쿼트, 벤치프레스, 데드리프트 세가지이다. 기록이 종목별 기준값보다 크면 등록시 인증 파일을 첨부해야한다. 기준값보다 낮은 기록은 바로 랭킹에 반영되어 순위가 표시되고 기준값보다 큰 기록은 심사를 통해 반영된다. 랭킹은 종목별로 유저 기록 중 시즌 내 가장 큰 값으로 계산된다.위 시나리오에서 랭킹 바운디드 컨택스 내 도메인을 다음과 같이 정의헀다정의된 도메인 내에서 트렌젝션 별로 어그리게이트를 나눠봤다.랭킹이 기록 등록과 함께 실시간으로 업데이트 되어야하면 같은 어그리게이트에 묶이는게 맞겠지만 모든 기록 등록이 랭킹의 변화로 이어지지 않고 기준치 이상의 기록은 심사가 완료되어야 업데이트 되기 때문에 다른 트렌젝션에서 처리된다고 판단했다.랭킹 컨텍스트에서 자체적으로 유저를 정의해야할까?User 서비스에서 모든 유저 정보를 관리할 수 있다. 하지만 생년월일, 성별, 몸무게를 수집하는 이유는 나중에 Ranking서비스에서 나이별, 체급별, 성별 별로 랭킹을 계산하기 위한 목적이다. 랭킹에서 유저를 새롭게 Athlete란 엔티티로 정의하고 관리할지 유저 서비스에서 정보를 가져올지 고민됐다.해결생년월일, 성별은 랭킹이 아닌 다른 서비스에서도 사용될 수 있는 속성이다. 유저는 랭킹에서 엔티티보다는 VO이기도 하다. 유저 서비스가 해당 엔티티를 관리하고 컨텍스트 매핑으로 두 바운디드 컨텍스트를 연결하는게 낫다고 생각했다.내가 두 바운디드 컨텍스트 개발에 관여하므로 변경을 추적할 수 있고, 랭킹에는 전체 유저정보가 필요한데 통신으로 전달하기는 데이터가 크고 전달이 빈번해 shared kernel 방식이 알맞다고 생각했다.유저 정보가 업데이트 되는 경우 도메인 이벤트를 정의하고 랭킹 서비스에서 새로운 기준으로 랭킹을 업데이트한다." }, { "title": "어디서 토큰을 인증할 것인가?", "url": "/posts/where-to-verify-a-user/", "categories": "인증", "tags": "API Gateway, Ingresss Controller, AWS, Kubernetes", "date": "2023-08-06 17:30:00 +0900", "snippet": "문제 상황JWT을 사용하면 인증서버의 퍼블릭 키로 토큰을 검증 할 수 있다. 인증 코드 구현은 어렵지 않다. 하지만 모든 서버에 이 기능이 각각 추가되면 코드의 응집도를 떨어트린다. 인증서버와의 불필요한 통신이 없으면서 인증을 한곳에 응집시킬 방법은 어떤게 있을까?환경 AWS 내 EKS사용 없이 직접 구성한 K8s 클러스터. 현재 Spring Boot 서버만 있지만 다른 종류 서버가 들어올 수 있음. 프런트는 Vite에 static website를 배포방법AWS API Gateway + Lambda authorizerAPI Gateway를 사용하면서 AWS Lambda를 사용해 토큰을 검증하고 인증된 트래픽만 벡앤드로 보낼 수 있다.aws 프리티어가 100만 requests와 400,000 GB-seconds의 compute time을 지원하고 JWT 검증은 필요메모리와 실행시간이 적으므로 비용걱정은 없다고 본다.장점 BE에 트래픽이 몰리는 것을 방지할 수 있다. 캐싱 지원 트래픽 throttling lambda로 검증된 요청만 필터링 MSA에 적합하다. 쉽게 요청을 모니터링 할 수 있다. aws fully managed service로 다운될 걱정이 적다.필요성에 대한 의문 K8s Ingress를 사용하지 않는다면 서비스마다 loadbalancer 인스턴스가 필요해 추가 비용이 든다. K8s Ingress를 사용한다면 Gateway를 두개 사용하는 것과 같아 API Gateway의 필요성이 적은것 같다. 프런트 서비스로의 라우팅은 Route53에서도 할 수 있다.Kubernetes Ingress ControllerNginx Kubernetes Ingress Controller는 JWT validation을 지원한다.(Nginx_JWT_Validation_Policy)장점 BE에 트래픽이 몰리는 것을 방지할 수 있다. 캐싱_지원 트래픽_rate_limit 검증된 요청만 필터링 MSA에 적합하다.단점 모든 기능을 직접 설정해야한다. single point of failure =&amp;gt; controller가 다운되면 전체 서비스가 다운된다.Multi module인증관련 코드를 모듈화하고 공통으로 사용할 수 있다. AOP로 만들어 놓고 인증이 필요한 경우 간단히 어노테이션을 추가하면 된다.장점 구현이 간단하다. 인증이 필요한 곳에 어노테이션만 추가하면 되서 직관적이다.단점 스프링 이외의 서버가 들어왔을 때 인증이 여러 곳에서 관리된다." }, { "title": "OAuth2.0", "url": "/posts/OAuth2.0/", "categories": "인증", "tags": "OAuth2.0", "date": "2023-07-24 23:40:00 +0900", "snippet": "프로젝트에서 구글, 카카오 연동이 필요해 OAuth에 대해 공부했다. 유저 아이디만 필요했기에 OAuth가 아닌 OpenId Connect가 필요한게 맞는 것 같다. OAuth에 대해 공부한 내용을 아래 정리한다.OAuth란 무엇인가OAuth는 ‘Open standard for acess delegation’의 축약이다. 사용자가 가입된 서비스의 정보에 다른 서비스의 접근을 허용할 때, 직접 아이디와 패스워드를 타 서비스에 넘길 필요 없이 안전하게 권한을 부여하는 방식을 정의한 프토토콜이다.OAuth 용어 정리client: 유저의 정보에 접근하고 싶은 서버이다.resource owner: client가 접근하고 싶은 정보의 주인, 일반적으로 유저이다.authorization server: 인증을 진행하는 서버resource server: client가 접근하고 싶은 정보를 가지고 있는 서버, 토큰이 있어야 접근 가능하다.FlowAuthorization Code Grant +----------+ | Resource | | Owner | | | +----------+ ^ | (B) +----|-----+ Client Identifier +---------------+ | -+----(A)-- &amp;amp; Redirection URI ----&amp;gt;| | | User- | | Authorization | | Agent -+----(B)-- User authenticates ---&amp;gt;| Server | | | | | | -+----(C)-- Authorization Code ---&amp;lt;| | +-|----|---+ +---------------+ | | ^ v (A) (C) | | | | | | ^ v | | +---------+ | | | |&amp;gt;---(D)-- Authorization Code ---------&#39; | | Client | &amp;amp; Redirection URI | | | | | |&amp;lt;---(E)----- Access Token -------------------&#39; +---------+ (w/ Optional Refresh Token)A: client가 resource owner의 정보에 접근하기위해 브라우저를 authroization endpoint로 이동시킨다. 인증 후 돌아올 redirection uri와 client identifier(public key), request scope를 함께 전달한다. B: 유저가 authorization server에서 client의 요청을 확인하고 동의한다.C: authorization code를 발급받고 client에 전달한다.D~E: authorization code를 토큰으로 교환한다.인증서버와 user agent의 통신은 front channel에서 이뤄지기에 A~C과정은 CSRF에 취약하다. 이 과정에서 토큰을 발급한다면 redirection uri를 변경해 가로챌 수 있을 것이다.back channel에서 authorization code를 토큰으로 교환하는 과정은 인증이 가능하다. client가 secret key로 서명할 수 있기에 authorization server는 public key로 제대로된 client와 소통하고 있는지 확인할 수 있다.스마트폰 앱과 같이 client secret이 기기에 포함되어 노출될 위험이 있는 경우에 access code 탈취는 위험하다. 이를 방지하기 위해 (A)과정에서 code_verifier를 생성해 토큰 발급시 확인하는 PKCE 프로토콜이 함께 사용된다.Reference Token vs Self Encoded TokenReferece token토큰은 인증을 위한 문자열일뿐 정보를 포함하지 않는다. 토큰과 정보를 매치할 저장소가 필요하다. 정보를 직접 관리할 수 있어 토큰 삭제, 유저 정보변경 등 데이터 정합성을 유지할 수 있는 장점이 있다. 인증에 저장소와 통신이 필요하기에 네트워크 지연이 생기고, 확장성이 떨어지는 단점이 있다.Self encoded tokenJWT이 대표적인 예이다. 토큰 자체에 정보를 포함한다. 인증서버의 public key를 알면 토큰의 유효성을 검증할 수 있어 네트워크 트래픽이 필요 없고, 확장성이 높다. 저장된 정보는 발급된 시점에서만 유효한 정보기에 데이터 정합성이 맞지 않을 수 있는 단점이 있다." }, { "title": "Context Switch", "url": "/posts/context-switch/", "categories": "운영체제", "tags": "OS, context switch, limited direct execution", "date": "2022-05-03 18:00:00 +0900", "snippet": "프로세스가 cpu에서 실행되고 있을 때, OS는 실행되지 않는다. 그러면 어떻게 OS가 실행중인 프로세스를 다른 프로세스로 전환할까?Timer interrupt프로세스에서 system call을 호출할때까지 기다려 OS가 컨트롤을 되찾을 수도 있지만, 프로그램이 무한 루프에 빠진다면 이를 되찾을 방법은 없다. 이에 하드웨어에서 타이머를 설정하고 특정 주기로 인터럽트를 발생시켜 OS를 호출한다.Context switch timeline OS(kernel mode) Hardware Program(user mode) boot     Initialize trap table       remember address of syscall handler remember address of timer handler   start interrupt timer       start timer interrupt CPU in X ms   run         Process A   timer interrupt     save registers(A) to kernel stack(A) move to kernel mode jump to trap handler   Handle the trap     Call switch() routine save regs(A) into PCB(A) restore regs(B) from PCB(B) switch to k-stack(B)     return-from-trap (into B)       restore regs(B) from kernel stack(B) move to user mode jump to B’s PC       Process B *Why do we store/resotre registers to both kernel stack and PCB?모든 레지스터의 값이 PCB에 저장되는 것이 아니다. PCB의 esp에는 kernel stack의 주소만 저장된다. 이를 이용해 kernel stack에서 레지스터를 복구한다." }, { "title": "System call", "url": "/posts/system-call/", "categories": "운영체제", "tags": "OS, system call, limited direct execution", "date": "2022-05-03 14:00:00 +0900", "snippet": "무엇을 공부해할지 오래 헤맸다. 주니어인 지금 운영체제, 네트워크, 데이터베이스 이론을 제대로 공부하면 앞으로의 개발이 편해질 것이란 결론이 나왔다. 우선 Operating Systems: Three Easy Pieces를 보며 공부하는 중이다. (과제 깃)What is System Call?cpu는 두가지 processor mode를 가진다. OS가 컨트롤을 가지는 kernel mode에서는 기능이 제한되지 않지만 프로세스가 실행되는 user mode에서는 보안을 위해 시스템에 영향을 줄 수 있는 기능이 제한된다. user mode에서도 제한된 기능을 사용할 수 있도록 제공되는 기능이 system call이다. 즉 프로세스가 OS에 컨트롤을 넘기고 결과를 돌려받는 것이다.Trap, Trap table, Trap handlertrap은 user mode에서 kernel mode로 전환시킨다. kernel mode에서 프로그램의 어떤 코드라도 실행 가능하다면 보안에 치명적일 것이다. 이를 방지하기 위해 trap table이 존재하고 프로세스가 요청할 수 있는 기능이 제한된다. system call이 요청되면 OS는 system-call number에 맞는 trap handler를 trap table내에서 찾아 실행시킨다.Procedure of system callBrief process trap instruction이 실행되며 user mode에서 kernel mode로 전환된다. 실행되고 있는 프로그램이 return-from-trap 후에 다시 정상적으로 실행될 수 있도록 PC, 레지스터 정보가 kernel stack에 저장된다. syscall이 실행된다. return-from-trap이 실행된다. kernel stack에 넣은 값을 복구하고 user mode에서 PC의 다음 명렬을 수행한다.Timeline OS(kernel mode) Hardware Program(user mode) boot     Initialize trap table       remember address of syscall handler   run program     Create entry for process list Allocate memory for program Load program into memory Setup user stack with argv Fill kernel stack with reg/PC     return from trap       restore regs from kernel stack move to user mode jump to main       Run main() execute instructions Call system call     trap into OS   save regs to kernel stack move to kernel mode jump to trap handler   Handle trap do work of syscall     return from trap       restore regs from kernel stack move to user mode jump to PC after trap       execute instructions exit()     trap Free memory of processes Remove from process list     " }, { "title": "냅색 문제", "url": "/posts/%EB%83%85%EC%83%89%EB%AC%B8%EC%A0%9C/", "categories": "알고리즘", "tags": "dynamic programming, 배낭문제, knapsack", "date": "2022-02-18 14:00:00 +0900", "snippet": "남는 시간에 https://www.acmicpc.net/step 에 있는 알고리즘 문제들을 처음부터 쭉 풀어보고 있다. 오늘 작성할 문제는 dp의 대표적인 문제인 배낭 문제(knapsack problem) 이다.Problem 백준 평범한 가방가방에 담을 수 있는 무게의 최대값 k와 물건의 총 개수 n, 그리고 각 물건의 무게와 가치가 주어진다. 가방안에 무게가 k가 되지 않도록 물건을 넣을때 가방에 담을 수 있는 가치 합의 최대값을 구한다.SolutionIdeaX축을 무게 Y축을 가치로 하는 XY평면에 점을찍어 Y최댓값을 찾는다. 새로운 무게를 추가할때는 그래프에 표시된 모든점에 (x_old+x_new, y_old+y_new)를 계산하고 더해진 X에 Y값이 이미 존재하는 경우 Y를 더 큰 값으로 업데이트 한다.Codeimport sysfrom collections import defaultdictinput_ = sys.stdin.readlinen, k = map(int, input_().split())items = [tuple(map(int, input_().split())) for _ in range(n)]values = defaultdict(int)values[0] = 0for cur_weight, cur_value in items: keys = sorted(values.keys(), reverse=True) for last_weight in keys: added_weight = last_weight+cur_weight if added_weight &amp;gt; k: continue values[added_weight] = max(values[added_weight], values[last_weight]+cur_value)print(max(values.values()))What I missed처음에는 12번 라인이 무게가 큰 순서대로 정렬하는 대신 list(values.keys())였다. 이에 따라 17번 라인에서 새 무게에 대한 가치를 업데이트 할 때 업데이트 한 내용을 다시 읽어 더하는 문제가 있었다.Counterexample:4 105 35 52 23 2wrong output : 10expected output: 9위와 같은 입력이 주어지는 경우 values[5] = 5로 업데이트 된 채 values[10]을 계산해 최대 가치가 10으로 나온다. 이에 매번 키를 무게가 큰 순서대로 정렬해 한 iteration에서 자신이 업데이트 한 값을 다시 읽는 것을 막아야했다.배열을 선언하는 대신 딕셔너리를 사용한 것은 정확히 len(keys)만큼만 연산을 진행하려 한것인데, 매번 정렬을 하게되어 좋은 코드가 아니게 되었다.Time Complexity (Big-O)딕셔너리 key길이의 최대값이 k이므로 kn의 복잡도를 가진다. 만약 k가 무한하다면 $n*2^n$의 복잡도를 가진다.(ex: 입력이 $a^0, a^1, a^2, …, a^{n-1}$) 으로 들어옴)Other SolutionsBig-O에서 시간 복잡도는 같다. 배열을 순차적으로 업데이트 해서 매번 불필요한 정렬이 사라진다.Traditional Knapsacki를 가방의 최대 허용 무게, j를 탐색한 아이탬의 인덱스로 표현했을 때 점화식은 다음과 같다. $dp[i][j] = max(dp[i][j-1], dp[i-w_j][j-1]+v_j)$Codeimport sysinput_ = sys.stdin.readlinen, k = map(int, input_().split())items = [tuple(map(int, input_().split())) for _ in range(n)]dp = [[0]*(n+1) for _ in range(k+1)]for i in range(1, k+1): for j in range(1, n+1): weight = items[j-1][0] value = items[j-1][1] if weight &amp;gt; i: dp[i][j] = dp[i][j-1] else: dp[i][j] = max(dp[i][j-1], dp[i-weight][j-1]+value)print(dp[k][n])불필요한 정렬이 사라지고 big-o 복잡도가 같아 다음 코드가 더 빠를 것이라 생각했는데 백준 테스트 케이스 실행 시간이 632ms(PyPy3)가 걸렸다. 원래 코드의 실행 시간이 328ms로 두배 가까이 느리다.위 코드는 언제나 kn을 모두 탐색하지만 내 코드는 탐색할 keys의 길이가 worst case에서 k여서 klog(k)의 정렬 시간을 포함해도 평균 복잡도가 현재 주어진 테스트 케이스에 대해서는 나은 것 같다.Best Solution일차원 배열을 사용해 공간복잡도를 줄인 방법이다. 이차원 배열을 사용하는 냅색문제에서 사실 중요한것은 배낭 크기에대한 가치의 최댓값 뿐이다. 이에 i,j로 표현하던 배열을 i번째 아이템까지 탐색하면서 최댓값을 업데이트하는 방식으로 바꿀 수 있다. 점화식은 다음과 같다.$dp[i] = max(dp[i], dp[i-w_j]+v_j)$코드에서는 배열을 뒤에서 부터 업데이트해 자신이 업데이트 한 값을 다시 업데이트 하는 것을 막는다.Codeimport sysinput_ = sys.stdin.readlinen, k = map(int, input_().split())items = [tuple(map(int, input_().split())) for _ in range(n)]dp = [0]*(k+1)for weight, value in items: for i in range(k, weight-1, -1): dp[i] = max(dp[i-weight]+value, dp[i])print(dp[k])백준 테스트 케이스에 대해 실행 시간이 160ms로 가장 빠르다." }, { "title": "개발블로그 시작", "url": "/posts/%EA%B0%9C%EB%B0%9C%EB%B8%94%EB%A1%9C%EA%B7%B8%EC%8B%9C%EC%9E%91/", "categories": "일상", "tags": "자유", "date": "2022-02-17 13:30:00 +0900", "snippet": "오늘로 개발 블로그를 시작했다. 개발 일지를 작성할 필요는 계속 느끼고 있었다. 예전에는 해결법을 찾고 적용해보기만 하면 내 것이 되는 줄 알았다. 전에 작성한 안드로이드 코드를 보수하면서, 예전에 풀었던 문제인데도 다시 구체적인 방법을 찾는데 시간을 쏟고 있었다.필요성을 느꼈음에도 지금 시작하지 않은 이유는 누군가에게 보여준다는 부담감 때문이었다. 완벽하게 읽기 쉽게 정리해야 한다는 생각에 아예 쓰지 않았다.이번에는 온전히 나를 위해 글을 쓰려고 한다. 사소한 문제 해결 방법부터, 개발 일지, 공부한 내용의 요약을 나중의 내가 다시 떠올리기 쉽도록 적을 것이다. 그 과정에서 글이 누군가에게 도움이 되면 좋겠지만, 무엇보다도 나를 위해 쓰자." } ]
